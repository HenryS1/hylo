(defpackage :range
  (:use :cl :monad)
  (:export :between :to-array :append-ranges :reduce-range :index :memoization
           :self
           :size
           :fmap-rec))

(in-package :range)

(defclass range ()
  ((size :accessor size :initarg :size)
   (transformation :accessor transformation :initarg :transformation :initform #'identity)
   (memoization :accessor memoization :initarg :memoization :initform nil)))

(defun between (start end &key (memoize nil))
  (make-instance 'range :size (+ (- end start) 1) 
                 :transformation (lambda (i) i)
                 :memoization (when memoize (lambda (i) i))))

(defun to-array (range &key (type t))
  (let ((arr (make-array (size range) :element-type type :adjustable nil)))
    (loop for i from 0 to (- (size range) 1)
       do (setf (aref arr i) (index range i)))
    arr))

(defun append-ranges (one other)
  (declare (optimize (speed 3)))
  (let* ((one-f (transformation one))
         (other-f (transformation other))
         (one-size (size one))
         (new-f (lambda (i) 
                  (if (>= i one-size)
                      (funcall other-f (- i one-size))
                      (funcall one-f i)))))
    (declare (function one-f other-f new-f))
    (make-instance 'range :size (+ (size one) (size other)) :transformation new-f)))

(defun fib (n)
  (cond ((= n 0) 1)
        ((= n 1) 1)
        (t (+ (fib (- n 1)) (fib (- n 2))))))

(defmacro fmap-rec (f range)
  (let ((self (intern "SELF" (package-name *package*))))
    `(let (,self)
       (setf ,self (fmap ,f ,range)))))

(defmacro mem-lambda (args &rest body)
  `(let ((table (make-hash-table :test 'equal)))
     (labels ((self ,args
                (if (gethash (list ,@args) table)
                    (gethash (list ,@args) table)
                    (setf (gethash (list ,@args) table)
                          ,@body))))
       #'self)))

(defmethod fmap (f (range range))
  (declare (optimize (speed 3))
           (function f))
  (let ((old-f (transformation range)))
    (declare (function old-f))
    (make-instance 'range :size (size range) 
                   :transformation (lambda (i) (funcall f (funcall old-f i)))
                   :memoization (when (memoization range)
                                  (let* ((table (make-hash-table :test 'equal)))
                                    (lambda (i)
                                      (if (gethash i table)
                                          (gethash i table)
                                          (setf (gethash i table) 
                                                (funcall f (funcall old-f i))))))))))

(defun merge-ranges (f range start end)
  (declare (optimize (speed 3)))
  (if (= start end)
      (let ((old-f (transformation range)))
        (declare (function f old-f))
        (funcall f (funcall old-f start)))
      (let* ((mid (floor (+ start end) 2))
             (left (merge-ranges f range start mid))
             (right (merge-ranges f range (+ mid 1) end)))
        (append-ranges left right))))

(defmethod flatmap (f (range range))
  (merge-ranges f range 0 (- (size range) 1)))

(defun index (range i)
  (when (< i (size range))
    (if (memoization range)
        (funcall (memoization range) i)
        (funcall (transformation range) i))))

(defun reduce-range (op range)
  (declare (optimize (speed 3))
           (function op))
  (let ((len  (- (size range) 1))
        (f (if (memoization range) (memoization range) (transformation range))))
    (declare (function f))
    (loop for i fixnum from 0 to len
       for e = (funcall f i)
       for result = e then (funcall op result e)
       finally (return result))))

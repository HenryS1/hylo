(defpackage :range
  (:use :cl :monad)
  (:export :between :to-array :append-ranges :reduce-range :index))

(in-package :range)

(defclass range ()
  ((size :accessor size :initarg :size)
   (transformation :accessor transformation :initarg :transformation :initform #'identity)))

(defun between (start end)
  (make-instance 'range :size (+ (- end start) 1) 
                 :transformation (lambda (i) (when (<= i (- end start)) (+ i start)))))

(defun to-array (range &key (type t))
  (let ((arr (make-array (size range) :element-type type :adjustable nil))
        (f (transformation range)))
    (loop for i from 0 to (- (size range) 1)
       do (setf (aref arr i) (funcall f i)))
    arr))

(defun append-ranges (one other)
  (declare (optimize (speed 3)))
  (let* ((one-f (transformation one))
         (other-f (transformation other))
         (one-size (size one))
         (new-f (lambda (i) 
                  (if (>= i one-size)
                      (funcall other-f (- i one-size))
                      (funcall one-f i)))))
    (declare (function one-f other-f new-f))
    (make-instance 'range :size (+ (size one) (size other)) :transformation new-f)))

(defmethod fmap (f (range range))
  (declare (optimize (speed 3)))
  (let ((old-f (transformation range)))
    (declare (function old-f f))
    (make-instance 'range :size (size range) 
                   :transformation (lambda (i) (funcall f (funcall old-f i))))))

(defun merge-ranges (f range start end)
  (declare (optimize (speed 3)))
  (if (= start end)
      (let ((old-f (transformation range)))
        (declare (function f old-f))
        (funcall f (funcall old-f start)))
      (let* ((mid (floor (+ start end) 2))
             (left (merge-ranges f range start mid))
             (right (merge-ranges f range (+ mid 1) end)))
        (append-ranges left right))))

(defmethod flatmap (f (range range))
  (merge-ranges f range 0 (- (size range) 1)))

(defun index (range i)
  (funcall (transformation range) i))

(defun reduce-range (op range)
  (declare (optimize (speed 3)))
  (let ((f (transformation range))
        (len (- (size range) 1)))
    (declare (function f op))
    (loop for i fixnum from 0 to len
       for e = (funcall f i)
       for result = e then (funcall op result e)
       finally (return result))))
